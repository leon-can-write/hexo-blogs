{"pages":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hexo-blogs/hello-world.html"}],"posts":[{"title":"C编译器实现1","text":"1. 配置这里给出 Yacc&amp;Bison 的 Win &amp; Linux 两种配置方式。 个人喜欢 Windows， 因为可以用宇宙第一IDE VS。 Windows在 Windows 上给 Visual Studio 配置 Bison &amp; Flex 环境。 Bison &amp; Flex 绿化Bison下载: http://gnuwin32.sourceforge.net/packages/bison.htm 下的是 Package Flex 下载: http://gnuwin32.sourceforge.net/packages/flex.htm 下的是 Package, 两者下载安装。 接下来这个绿化步骤是可选的，绿化主要是为了方便队友开箱即用。 首先我们把 Bison&amp;Flex 安装目录里的 GnuWin32 文件夹拷贝出来， 注意 GnuWin32 所在目录路径不能包含空格。比如这样的目录结构: 12345D:/ - bin/ - GnuWin32/ - flex.exe - flex++.exe 把 D:/bin 加入环境变量的路径里。 把下面的启动脚本命名为 bison.bat 复制到 bin 目录下。 (replace 函数其实不需要, 主要是帮强迫症统一路径格式用的) 1234567891011121314151617181920212223242526272829@echo offsetlocal EnableDelayedExpansionset \"str=%~dp0\"set \"char=\" &amp; set \"repl=\" &amp; set \"loc=0\":: 把路径里的 '\\' 替换成 '/'call :replace:: 设置环境路径SET PATH=%repl%GnuWin32/bin;%PATH%@echo on:: 调用 bison%repl%GnuWin32/bin/bison.exe %*@echo offexit /b:: 替换字符的函数:replace set \"char=!str:~%loc%,1! if \"!char!\" == \"\" exit /b if \"!char!\" equ \"\\\" set \"char=/\" set \"repl=!repl!!char!\" set /a \"loc+=1\"goto :replaceendlocal 同样的，添加 flex.bat 启动脚本: 1234567891011121314151617181920212223242526272829@echo offsetlocal EnableDelayedExpansionset \"str=%~dp0\"set \"char=\" &amp; set \"repl=\" &amp; set \"loc=0\":: 把路径里的 '\\' 替换成 '/'call :replace:: 设置环境路径SET PATH=%repl%GnuWin32/bin;%PATH%@echo on:: 调用 bison%repl%GnuWin32/bin/flex.exe %*@echo offexit /b:: 替换字符的函数:replace set \"char=!str:~%loc%,1! if \"!char!\" == \"\" exit /b if \"!char!\" equ \"\\\" set \"char=/\" set \"repl=!repl!!char!\" set /a \"loc+=1\"goto :replaceendlocal 最后测试一下是否能工作: 1234567891011121314# flexPS D:\\bin&gt; flex -VD:\\bin\\flex.exe version 2.5.4PS D:\\bin&gt; bison -V# bisonD:\\bin&gt;D:/bin/GnuWin32/bin/bison.exe -Vbison (GNU Bison) 2.4.1Written by Robert Corbett and Richard Stallman.Copyright (C) 2008 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 然后就可以把原版的 Bison 卸载了。 Visual Studio 配置参考这里: https://stackoverflow.com/questions/6563378/yacc-and-bison-in-visual-studio, 一步步照做就好了 You need to add custom build rules for your .y and .l files. To do this, you need to create one dummy .c file for the .l file and the .y file add the .l, .y and both .c files to the project right click on the .l file and select properties Configuration-&gt;All Configurations General-&gt;Item Type-&gt;Custom Build Tool Apply Custom Build Tool-&gt;General-&gt;Command Line-&gt;flex -olexer.c lexer.l Custom Build Tool-&gt;General-&gt;Outputs-&gt;lexer.c Custom Build Tool-&gt;General-&gt;Additional Dependencies-&gt;parser.y parser.c Apply select the .y file in the solution explorer Configuration-&gt;All Configurations General-&gt;Item Type-&gt;Custom Build Tool Apply Custom Build Tool-&gt;General-&gt;Command Line-&gt;bison -oparser.c parser.y Custom Build Tool-&gt;General-&gt;Outputs-&gt;parser.c parser.h 注意在步骤 7 里面： -olexer.c 可能会报错, 使用 -o&quot;lexer.c&quot; 同样的 bison -oparsr.c parser.y 改成: 1bison -t -o\"parser.c\" -d parser.y 最后写好 lex &amp; yacc 文件就能VS里一键运行了！ LinuxLinux bison &amp; flex 能一键安装。 编译的时候可以用 Makefile: 12345678910111213141516171819CC = gccPROGRAM=xccFLEXFLAGS =SRCS = lexer.c parser.c ast.c main.cYFLAGS = -dCCFLAGS = all: $(PROGRAM)lexer.c: lex.l flex $(FLEXFLAGS) -olexer.c lex.lparser.c: parser.y bison $(YFLAGS) -oparser.c parser.ylexer: lexer.c parser.cxcc: $(SRCS) $(CC) -o $@ $(SRCS) $(CCFLAGS) -lfl -lm Makefile 的 .c.o: $(SRCS) 这种写法不知道为啥我跑不起来。","link":"/hexo-blogs/compilers/1.setup/"},{"title":"C编译器实现2","text":"2. Yacc编译器的下一步是词法和语义分析。","link":"/hexo-blogs/compilers/2.yacc/"},{"title":"C编译器实现3","text":"3. CoffCOFF 是 VS 生成的 Object 文件格式。貌似 ELF 和 COFF 差不多，COFF源于 System V的文件格式。 可以用 Coff Viewer查看 VS 生成的 Obj文件。Coff Viewer 地址: http://www.skycn.com/soft/appid/28526.html 本文参考的博客: https://www.cnblogs.com/weikanzong/p/5622899.html MS的文档: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format Unix 的 Coff 定义是这样的: http://www.delorie.com/djgpp/doc/coff/filhdr.html 而 Windows的 Coff是这样的: https://blog.kowalczyk.info/articles/pefileformat.html Unix 和 Windows 的 Coff 其实是一样的，只是在命名上Unix简洁 but 难懂。这里用 Windows 的Coff，更加易懂、清晰。","link":"/hexo-blogs/compilers/3.coff/"},{"title":"Computer Visions TODO Lists","text":"CVPR 2020 论文大盘点： https://zhuanlan.zhihu.com/p/154017806","link":"/hexo-blogs/computer%20visions/todo/"},{"title":"Dataming1","text":"Bayes’ TheoremThe conditional probability is given as follows:$$P(A|B)=P(A,B)/P(B)$$$P(A|B)$ means the probability of $A$ given $B$ has happened. $P(A, B)$ means the probability that both $A, B$ happen at the same time. But if $A, B$ are independent, then probability of $A$ does not depend on $B$, that is $P(A|B)=P(A)$, then we have $P(A, B)=P(A)P(B)$. Hence we have the bayers’ theorem:$$P(A|B) = \\frac{P(B|A)P(A)}{P(B)}$$WWe have names for the terms in the theorem: Term Name $P(A B)$ $P(B A)$ $P(A)$ prior We will have a quick walk through on what these names mean. Suppose someone knock at the door when we are having a class, are they a man or a woman? If there are more women in the school, then we will have more confident in saying the one at the door is a woman than a man. Our speculation is based on priori, and a formal definition of that is given as follows:$$\\text{A priori (prior) is probability of the state of nature.}$$ We can use other information to heWlp us recognize the gender of the one at the door, like their clothing, their appearance etc. $P(A|B_{man}) &amp; P(A|B_{woman})$ helps us to tell the difference between appearance of man and woman. So the likelihood is defined as:$$\\text{Likelihood is a measurement or feature} \\ \\text{on the state if the nature.}$$","link":"/hexo-blogs/courses/datamining.1.bayers/"},{"title":"Git Misc Operations","text":"Specify users for repositoriesSometimes we need to assign a different user for the repository, and push it to remote with this user account. First we do the routine that: create a ssh key upload ssh key to github open bash and type in ssh-agent bash to start ssh-agent type in ssh-add ./blog_id_rsa to add the ssh key Then we edit ~/.ssh/config: 1234Host leon-can-write HostName github.com User leon-can-write IdentityFile ~/.ssh/blog_id_rsa Next step is optional. We set local username &amp; email. Enter the local git repository, then type: 12git config user.email leon-can-write@live.comgit config user.user leon-can-write to set up email and user. Note that there is no --global or --local since the default option is --local. Finally we tell git which entry to use in the ssh config file: 1234git remote set-url origin git@leon-can-write:leon-can-write/hexo-blogs.git# ^~~~~~~~~~~~~~ ^^^^^^^^^^^^^^ ^---------# Host git repository# username","link":"/hexo-blogs/gits/1.misc-operations/"},{"title":"Adam 优化器","text":"Momentum阻碍模型收敛的一个最大问题是，其迭代的方向总是和最小值不一样，就是所谓的震荡效应。 一个简单的解决办法是，我们把上一次迭代方向和下次迭代方向平均一下，这样子就能消除震荡的部分。我们可以用指数平均去保存更久远的迭代方向, 假设我们要优化的参数是 $W$, 那么我们有:$$V_{dW} = \\beta V_{dW} + (1-\\beta)dW\\quad (指数平均)\\W = W - \\alpha V_{dW} \\quad(更新参数)$$ RMSporp全称是 Root Mean Prop. 这个的基本思想是，如果一个迭代方向的历史一直偏大，说明这有一定的问题，我们需要减小这样的迭代方向的步长大小。 我们要计算：$$S_{dW} = \\beta S_{dW} + (1-\\beta)dW^2 \\W = W - \\alpha \\frac{dW}{\\sqrt{S_{dW}} + \\epsilon}$$$\\epsilon$ 在分母防止除以 0 AdamAdam 的想法是把 Momentum 和 RMSprop 整合起来: $$V_{dW} = \\beta_1 V_{dW} + (1-\\beta_1)dW\\quad (指数平均)\\S_{dW} = \\beta_2 S_{dW} + (1-\\beta_2)dW^2 (RMSprop)\\V_{dW}^{corrected} = \\frac{V_{dW}}{1-\\beta_1^t} (无偏估计)\\S_{dW}^{corrected} = \\frac{S_{dW}}{1-\\beta_2^t} (无偏估计)\\ W=W-\\alpha\\frac{V_{dW}^{corrected}}{\\sqrt{S_{dW}^{corrected}} + \\epsilon}$$","link":"/hexo-blogs/machine%20learning/001.adam.optimizer/"},{"title":"C编译器实现A1","text":"Appendix 1. Microsoft YaccMicrosoft Docs: https://docs.microsoft.com/en-us/cpp/c-language/phrase-structure-grammar?view=vs-2019 Source of the Docs: https://github.com/MicrosoftDocs/cpp-docs/blob/master/docs/c-language/summary-of-declarations.md Summary of Expressionsprimary-expression:&nbsp;&nbsp;&nbsp;&nbsp;identifier&nbsp;&nbsp;&nbsp;&nbsp;constant&nbsp;&nbsp;&nbsp;&nbsp;string-literal&nbsp;&nbsp;&nbsp;&nbsp;( expression ) expression:&nbsp;&nbsp;&nbsp;&nbsp;assignment-expression&nbsp;&nbsp;&nbsp;&nbsp;expression , assignment-expression constant-expression:&nbsp;&nbsp;&nbsp;&nbsp;conditional-expression conditional-expression:&nbsp;&nbsp;&nbsp;&nbsp;logical-OR-expression&nbsp;&nbsp;&nbsp;&nbsp;logical-OR-expression ? expression : conditional-expression assignment-expression:&nbsp;&nbsp;&nbsp;&nbsp;conditional-expression&nbsp;&nbsp;&nbsp;&nbsp;unary-expression assignment-operator assignment-expression postfix-expression:&nbsp;&nbsp;&nbsp;&nbsp;primary-expression&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression [ expression ]&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression ( argument-expression-listopt )&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression . identifier&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression -&gt; identifier&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression ++&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression – argument-expression-list:&nbsp;&nbsp;&nbsp;&nbsp;assignment-expression&nbsp;&nbsp;&nbsp;&nbsp;argument-expression-list , assignment-expression unary-expression:&nbsp;&nbsp;&nbsp;&nbsp;postfix-expression&nbsp;&nbsp;&nbsp;&nbsp;++ unary-expression&nbsp;&nbsp;&nbsp;&nbsp;– unary-expression&nbsp;&nbsp;&nbsp;&nbsp;unary-operator&nbsp;&nbsp;&nbsp;&nbsp;cast-expression&nbsp;&nbsp;&nbsp;&nbsp;sizeof unary-expression&nbsp;&nbsp;&nbsp;&nbsp;sizeof ( type-name ) unary-operator: one of&nbsp;&nbsp;&nbsp;&nbsp;&amp; * + - ~ ! cast-expression:&nbsp;&nbsp;&nbsp;&nbsp;unary-expression&nbsp;&nbsp;&nbsp;&nbsp;( type-name ) cast-expression multiplicative-expression:&nbsp;&nbsp;&nbsp;&nbsp;cast-expression&nbsp;&nbsp;&nbsp;&nbsp;multiplicative-expression * cast-expression&nbsp;&nbsp;&nbsp;&nbsp;multiplicative-expression / cast-expression&nbsp;&nbsp;&nbsp;&nbsp;multiplicative-expression % cast-expression additive-expression:&nbsp;&nbsp;&nbsp;&nbsp;multiplicative-expression&nbsp;&nbsp;&nbsp;&nbsp;additive-expression + multiplicative-expression&nbsp;&nbsp;&nbsp;&nbsp;additive-expression - multiplicative-expression shift-expression:&nbsp;&nbsp;&nbsp;&nbsp;additive-expression&nbsp;&nbsp;&nbsp;&nbsp;shift-expression &lt;&lt; additive-expression&nbsp;&nbsp;&nbsp;&nbsp;shift-expression &gt;&gt; additive-expression relational-expression:&nbsp;&nbsp;&nbsp;&nbsp;shift-expression&nbsp;&nbsp;&nbsp;&nbsp;relational-expression &lt; shift-expression&nbsp;&nbsp;&nbsp;&nbsp;relational-expression &gt; shift-expression&nbsp;&nbsp;&nbsp;&nbsp;relational-expression &lt;= shift-expression&nbsp;&nbsp;&nbsp;&nbsp;relational-expression &gt;= shift-expression equality-expression:&nbsp;&nbsp;&nbsp;&nbsp;relational-expression&nbsp;&nbsp;&nbsp;&nbsp;equality-expression == relational-expression&nbsp;&nbsp;&nbsp;&nbsp;equality-expression != relational-expression AND-expression:&nbsp;&nbsp;&nbsp;&nbsp;equality-expression&nbsp;&nbsp;&nbsp;&nbsp;AND-expression &amp; equality-expression exclusive-OR-expression:&nbsp;&nbsp;&nbsp;&nbsp;AND-expression&nbsp;&nbsp;&nbsp;&nbsp;exclusive-OR-expression ^ AND-expression inclusive-OR-expression:&nbsp;&nbsp;&nbsp;&nbsp;exclusive-OR-expression&nbsp;&nbsp;&nbsp;&nbsp;inclusive-OR-expression | exclusive-OR-expression logical-AND-expression:&nbsp;&nbsp;&nbsp;&nbsp;inclusive-OR-expression&nbsp;&nbsp;&nbsp;&nbsp;logical-AND-expression &amp;&amp; inclusive-OR-expression logical-OR-expression:&nbsp;&nbsp;&nbsp;&nbsp;logical-AND-expression&nbsp;&nbsp;&nbsp;&nbsp;logical-OR-expression || logical-AND-expression Summary of Declarationsdeclaration:&nbsp;&nbsp;&nbsp;&nbsp;declaration-specifiers attribute-seqopt init-declarator-listopt ; declaration-specifiers:&nbsp;&nbsp;&nbsp;&nbsp;storage-class-specifier declaration-specifiersopt&nbsp;&nbsp;&nbsp;&nbsp;type-specifier declaration-specifiersopt&nbsp;&nbsp;&nbsp;&nbsp;type-qualifier declaration-specifiersopt attribute-seq :&nbsp;&nbsp;&nbsp;&nbsp;/* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;attribute attribute-seqopt attribute : one of&nbsp;&nbsp;&nbsp;&nbsp;/* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;__asm __clrcall __stdcall __based __fastcall __thiscall __cdecl __inline __vectorcall init-declarator-list:&nbsp;&nbsp;&nbsp;&nbsp;init-declarator&nbsp;&nbsp;&nbsp;&nbsp;init-declarator-list , init-declarator init-declarator:&nbsp;&nbsp;&nbsp;&nbsp;declarator&nbsp;&nbsp;&nbsp;&nbsp;declarator = initializer /* For scalar initialization */ storage-class-specifier:&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;&nbsp;&nbsp;&nbsp;__declspec ( extended-decl-modifier-seq ) /* Microsoft-specific */ type-specifier:&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;__int8 /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;__int16 /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;__int32 /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;__int64 /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;&nbsp;&nbsp;signed&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;&nbsp;&nbsp;&nbsp;struct-or-union-specifier&nbsp;&nbsp;&nbsp;&nbsp;enum-specifier&nbsp;&nbsp;&nbsp;&nbsp;typedef-name type-qualifier:&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;&nbsp;&nbsp;&nbsp;volatile declarator:&nbsp;&nbsp;&nbsp;&nbsp;pointeropt direct-declarator direct-declarator:&nbsp;&nbsp;&nbsp;&nbsp;identifier&nbsp;&nbsp;&nbsp;&nbsp;( declarator )&nbsp;&nbsp;&nbsp;&nbsp;direct-declarator [ constant-expressionopt ]&nbsp;&nbsp;&nbsp;&nbsp;direct-declarator ( parameter-type-list ) /* New-style declarator */&nbsp;&nbsp;&nbsp;&nbsp;direct-declarator ( identifier-listopt ) /* Obsolete-style declarator */ pointer:&nbsp;&nbsp;&nbsp;&nbsp;* type-qualifier-listopt&nbsp;&nbsp;&nbsp;&nbsp;* type-qualifier-listopt pointer parameter-type-list:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* The parameter list */&nbsp;&nbsp;&nbsp;&nbsp;parameter-list&nbsp;&nbsp;&nbsp;&nbsp;parameter-list , … parameter-list:&nbsp;&nbsp;&nbsp;&nbsp;parameter-declaration&nbsp;&nbsp;&nbsp;&nbsp;parameter-list , parameter-declaration type-qualifier-list:&nbsp;&nbsp;&nbsp;&nbsp;type-qualifier&nbsp;&nbsp;&nbsp;&nbsp;type-qualifier-list type-qualifier enum-specifier:&nbsp;&nbsp;&nbsp;&nbsp;enum identifieropt { enumerator-list }&nbsp;&nbsp;&nbsp;&nbsp;enum identifier enumerator-list:&nbsp;&nbsp;&nbsp;&nbsp;enumerator&nbsp;&nbsp;&nbsp;&nbsp;enumerator-list , enumerator enumerator:&nbsp;&nbsp;&nbsp;&nbsp;enumeration-constant&nbsp;&nbsp;&nbsp;&nbsp;enumeration-constant = constant-expression enumeration-constant:&nbsp;&nbsp;&nbsp;&nbsp;identifier struct-or-union-specifier:&nbsp;&nbsp;&nbsp;&nbsp;struct-or-union identifieropt { struct-declaration-list }&nbsp;&nbsp;&nbsp;&nbsp;struct-or-union identifier struct-or-union:&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;&nbsp;&nbsp;&nbsp;union struct-declaration-list:&nbsp;&nbsp;&nbsp;&nbsp;struct-declaration&nbsp;&nbsp;&nbsp;&nbsp;struct-declaration-list struct-declaration struct-declaration:&nbsp;&nbsp;&nbsp;&nbsp;specifier-qualifier-list struct-declarator-list ; specifier-qualifier-list:&nbsp;&nbsp;&nbsp;&nbsp;type-specifier specifier-qualifier-listopt&nbsp;&nbsp;&nbsp;&nbsp;type-qualifier specifier-qualifier-listopt struct-declarator-list:&nbsp;&nbsp;&nbsp;&nbsp;struct-declarator struct-declarator-list , struct-declarator struct-declarator:&nbsp;&nbsp;&nbsp;&nbsp;declarator&nbsp;&nbsp;&nbsp;&nbsp;type-specifier declaratoropt : constant-expression parameter-declaration:&nbsp;&nbsp;&nbsp;&nbsp;declaration-specifiers declarator /* Named declarator */&nbsp;&nbsp;&nbsp;&nbsp;declaration-specifiers abstract-declaratoropt /* Anonymous declarator */ identifier-list: /* For old-style declarator */&nbsp;&nbsp;&nbsp;&nbsp;identifier&nbsp;&nbsp;&nbsp;&nbsp;identifier-list , identifier abstract-declarator: /* Used with anonymous declarators */&nbsp;&nbsp;&nbsp;&nbsp;pointer&nbsp;&nbsp;&nbsp;&nbsp;pointeropt direct-abstract-declarator direct-abstract-declarator:&nbsp;&nbsp;&nbsp;&nbsp;( abstract-declarator )&nbsp;&nbsp;&nbsp;&nbsp;direct-abstract-declaratoropt [ constant-expressionopt ]&nbsp;&nbsp;&nbsp;&nbsp;direct-abstract-declaratoropt ( parameter-type-listopt ) initializer:&nbsp;&nbsp;&nbsp;&nbsp;assignment-expression&nbsp;&nbsp;&nbsp;&nbsp;{ initializer-list } /* For aggregate initialization */&nbsp;&nbsp;&nbsp;&nbsp;{ initializer-list , } initializer-list:&nbsp;&nbsp;&nbsp;&nbsp;initializer&nbsp;&nbsp;&nbsp;&nbsp;initializer-list , initializer type-name:&nbsp;&nbsp;&nbsp;&nbsp;specifier-qualifier-list abstract-declaratoropt typedef-name:&nbsp;&nbsp;&nbsp;&nbsp;identifier extended-decl-modifier-seq:&nbsp;&nbsp;&nbsp;&nbsp;/* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;extended-decl-modifieropt&nbsp;&nbsp;&nbsp;&nbsp;extended-decl-modifier-seq extended-decl-modifier extended-decl-modifier:&nbsp;&nbsp;&nbsp;&nbsp;/* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;thread&nbsp;&nbsp;&nbsp;&nbsp;naked&nbsp;&nbsp;&nbsp;&nbsp;dllimport&nbsp;&nbsp;&nbsp;&nbsp;dllexport Summary of Statementsstatement:&nbsp;&nbsp;&nbsp;&nbsp;labeled-statement&nbsp;&nbsp;&nbsp;&nbsp;compound-statement&nbsp;&nbsp;&nbsp;&nbsp;expression-statement&nbsp;&nbsp;&nbsp;&nbsp;selection-statement&nbsp;&nbsp;&nbsp;&nbsp;iteration-statement&nbsp;&nbsp;&nbsp;&nbsp;jump-statement&nbsp;&nbsp;&nbsp;&nbsp;try-except-statement /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;try-finally-statement /* Microsoft-specific */ jump-statement:&nbsp;&nbsp;&nbsp;&nbsp;goto identifier ;&nbsp;&nbsp;&nbsp;&nbsp;continue ;&nbsp;&nbsp;&nbsp;&nbsp;break ;&nbsp;&nbsp;&nbsp;&nbsp;return expressionopt ; compound-statement:&nbsp;&nbsp;&nbsp;&nbsp;{ declaration-listopt statement-listopt } declaration-list:&nbsp;&nbsp;&nbsp;&nbsp;declaration&nbsp;&nbsp;&nbsp;&nbsp;declaration-list declaration statement-list:&nbsp;&nbsp;&nbsp;&nbsp;statement&nbsp;&nbsp;&nbsp;&nbsp;statement-list statement expression-statement:&nbsp;&nbsp;&nbsp;&nbsp;expressionopt ; iteration-statement:&nbsp;&nbsp;&nbsp;&nbsp;while ( expression ) statement&nbsp;&nbsp;&nbsp;&nbsp;do statement while ( expression ) ;&nbsp;&nbsp;&nbsp;&nbsp;for ( expressionopt ; expressionopt ; expressionopt ) statement selection-statement:&nbsp;&nbsp;&nbsp;&nbsp;if ( expression ) statement&nbsp;&nbsp;&nbsp;&nbsp;if ( expression ) statement else statement&nbsp;&nbsp;&nbsp;&nbsp;switch ( expression ) statement labeled-statement:&nbsp;&nbsp;&nbsp;&nbsp;identifier : statement&nbsp;&nbsp;&nbsp;&nbsp;case constant-expression : statement&nbsp;&nbsp;&nbsp;&nbsp;default : statement try-except-statement: /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;__try compound-statement __except ( expression ) compound-statement try-finally-statement: /* Microsoft-specific */&nbsp;&nbsp;&nbsp;&nbsp;__try compound-statement __finally compound-statement External Definitionstranslation-unit:&nbsp;&nbsp;&nbsp;&nbsp;external-declaration &nbsp;&nbsp;&nbsp;&nbsp;translation-unit external-declaration external-declaration: /* Allowed only at external (file) scope */&nbsp;&nbsp;&nbsp;&nbsp;function-definition&nbsp;&nbsp;&nbsp;&nbsp;declaration function-definition: /* Declarator here is the function declarator */&nbsp;&nbsp;&nbsp;&nbsp;declaration-specifiersopt declarator declaration-listopt compound-statement","link":"/hexo-blogs/compilers/appendix1.ms.yacc/"}],"tags":[{"name":"compiler","slug":"compiler","link":"/hexo-blogs/tags/compiler/"},{"name":"c","slug":"c","link":"/hexo-blogs/tags/c/"},{"name":"environment","slug":"environment","link":"/hexo-blogs/tags/environment/"},{"name":"computer visions","slug":"computer-visions","link":"/hexo-blogs/tags/computer-visions/"},{"name":"cvpr","slug":"cvpr","link":"/hexo-blogs/tags/cvpr/"},{"name":"data mining","slug":"data-mining","link":"/hexo-blogs/tags/data-mining/"},{"name":"bayers","slug":"bayers","link":"/hexo-blogs/tags/bayers/"},{"name":"git","slug":"git","link":"/hexo-blogs/tags/git/"},{"name":"machine learning","slug":"machine-learning","link":"/hexo-blogs/tags/machine-learning/"},{"name":"ml optimization","slug":"ml-optimization","link":"/hexo-blogs/tags/ml-optimization/"}],"categories":[{"name":"compiler","slug":"compiler","link":"/hexo-blogs/categories/compiler/"},{"name":"cv","slug":"cv","link":"/hexo-blogs/categories/cv/"},{"name":"courses","slug":"courses","link":"/hexo-blogs/categories/courses/"},{"name":"gits","slug":"gits","link":"/hexo-blogs/categories/gits/"},{"name":"machine learning","slug":"machine-learning","link":"/hexo-blogs/categories/machine-learning/"}]}